/**
 * Лабораторная работа №3. Перегрузка операторов, константные методы, битовые
 * поля, объединения.
 *
 * В этой работе и далее предполагается, что вы будете использовать классы,
 * написанные в прошлых работах, и дополнять их по необходимости. Эти классы
 * будут называться по имени без дополнительных указаний, что их надо взять из
 * прошлой работы.
 *
 * Предполагается, что новый классы будут созданы по аналогии с предыдущими
 * работами в отдельных файлах, которые будут включены в сборку.
 *
 * При работе с классами - в учебных целях - нельзя пользоваться контейнерами
 * стандартной библиотеки и нужно следовать принципам инкапсуляции.
 */

#include <utility>
#include <cassert>
#include <iostream>

int main() {

    /**
     * Задание 1. Перегрузка операторов.
     */

    /**
     * Задание 1.1. Оператор присваивания.
     *
     * Перегрузите оператор присваивания для классов `MyString` и `Matrix`.
     * Ожидается, что оператор присваивания работает так же, как конструктор
     * копирования. 
     *
     * Проверьте корректность работы оператора в следующих блоках кода.
     */

    /* {
            MyString s1("AAA"), s2;
            s2 = s1;
            s1 = "CCC";
            s2 = MyString("tmp");
            s1 = s1;
    } */

    /* {
        Matrix m1(10), m2(10, 2);
        m1 = m2;
        m2 = Matrix(3, 4, 1.0);
        m1 = m1;
    } */

    /**
     * Задание 1.2. Перегрузка арифметических операторов. Перегрузка методами и
     * глобальными функциями.
     */

    /**
     * Задание 1.2.1. Составное присваивание.
     *
     * Для класса `Matrix` перегрузите следующие операторы методом класса:
     * - `+=` и `-=` с объектом класса `Matrix`;
     * - `*=` и `/=` со значением double.
     *
     * Такие операторы не должны менять правый операнд. При наличии недопустимых
     * аргументов выкиньте какое-нибудь исключение.
     *
     * Ваши операторы должны работать в следующем блоке кода.
     */

    /* {
        Matrix m1(4), m2(4, 4, 1);
        m2 += m1;
        m2 -= m1 += m1;
        m1 *= 2;
        m2 /= 3;
    } */

    /**
     * Задание 1.2.2. Бинарные операторы.
     *
     * Для класса `Matrix` перегрузите следующие операторы методом класса:
     * - `+` и `-` с объектом класса `Matrix`;
     * - `*` с объектом класса `Matrix`;
     * - `*` и `/` со значением double.
     *
     * Эти операторы не должны изменять ни левый, ни правый операнд и возвращать
     * новое значение.
     */

    /* {
        Matrix m1(4), m2(4, 4, 1);
        Matrix m3 = (m1 + m2) * m1 * 4 / 2 - m2;
    } */

    /**
     * Задание 1.2.3. Перегрузка глобальными функциями.
     *
     * Перегрузите оператор `*` для операндов `double` и `Matrix` глобальной
     * функцией.
     *
     * Перегрузите унарный оператор `-` для класса `Matrix` с помощью глобальной
     * функции.
     *
     * Какую из этих функций нельзя перегрузить методом класса? Почему?
     */

    /**
     * Задание 1.2.4. Операторы для строки.
     *
     * Перегрузите операторы `+` и `+=` для класса `MyString`, где в качестве
     * правого операнда будет `MyString` или `const char *`. Сложение в этом 
     * случае должно выполнять конкатенацию строк.
     *
     * Ваши операторы должны работать в следующем блоке кода.
     */

    /* {
        MyString s1("abc"), s2("def"), s3;
        s1 += s2 += "111";
        s2 += "222" + s1 + "333";
        s3 += s3;
    } */

    /**
     * Задание 1.3. Move-семантика.
     *
     * Перегрузите move-оператор присваивания и move-конструктор для классов
     * `MyString` и `Matrix`. В этих операторах нужно "забирать" данные из
     * правого операнда, а не копировать. При этом правый операнд должен
     * становиться "пустым".
     *
     * С помощью отладчика или отладочной печати отследите, сколько раз в
     * следующем блоке происходит выделение динамической памяти, - до реализации
     * move-оператора/конструктора и после.
     */

    /* {
        MyString s1("abc");
        MyString s2 = s1 + "ccc";
        s1 = "abc" + s2;
        s2 = std::move(s1);

        Matrix m1(4), m2 = m1 + m1;
        m1 = m2 * m1;
        m2 = std::move(m1);
    } */

    /**
     * Задание 1.4. Операторы сравнения.
     *
     * Реализуйте для класса `MyString` операторы сравнения `==`, `!=`, `<`,
     * `<=` для сравнения с объектами `MyString` и `const char *`.
     *
     * Операторы должны сравнивать строки лексикoграфически.
     */

    /* {
        MyString s1("abc"), s2("ab"), s3 = s1;
        assert(s2 < s1);
        assert(s1 == s3);
        assert(s1 != s2);
        assert(s1 <= s3);
        assert("ab" == s2);
        assert("aba" < s1);
        assert("aba" <= s3);
    } */

    /**
     * Задание 1.5. Оператор индексирования.
     *
     * Перегрузите оператор индексирования для класса `MyString`, который
     * возвращает ссылку на i-тый символ. Если индекс выходит за границы
     * массива, киньте какое-нибудь исключение.
     */

    /* {
        MyString s1("abc");
        s1[0] = s1[1] = 'd';
    } */

    /**
     * Задание 1.6. Операторы ввода и вывода с потоками стандартной библиотеки.
     *
     * Реализуйте для класса `MyString` операторы `<<`, который позволит
     * выводить строку в поток вывода `std::ostream`.
     *
     * Реализуйте для класса `MyString` оператор `>>`, который позволит вводить
     * строку до первого переноса строки из потока ввода `std::istream`.
     *
     * Проверьте работу этих операторов на следующем примере.
     */

    /* {
        MyString s("123");
        std::cout << "This is my string: ' << s << "'\n";
        std::cout << "Enter your string: ";
        std::cin >> s;
        std::cout << "Your string: '" << s << "'\n";
    } */

    /**
     * Задание 2. Константные методы.
     *
     * Объявите все методы (в том числе перегруженные операторы), которые не
     * должны менять объект, для которого они были вызваны, константными.
     *
     * После этого следующая функция должна собираться:
     *
     * MyString addTxtExtension(const MyString &path) { return path + ".txt"; }
     */

    /**
     * Задание 3. Ассоциативный массив. Итератор. Операторы инкремента.
     */

    /**
     * Задание 3.1. Ассоциативный массив.
     *
     * Создайте класс `WorkerDb`, который будет хранить базу данных рабочих
     * некой организации в виде ассоциативного массива. В таком массиве индексом
     * является не номер элемента, а какое-то другое значение. В этом случае -
     * фамилия сотрудника. В самом же массиве будет храниться структура с
     * информацией о работнике.
     *
     * Реализуйте для этого класса оператор `[]`, который будет по фамилии
     * возвращать ссылку на данные работника. Если такого работника еще нет,
     * то запись для этого работника создается.
     *
     * Используйте для хранения строковых данных ваш класс MyString.
     */

    /* {
        WorkerDb db;
        db["Ivanov"] = WorkerData("Ivan", 34, ...);
        db["Petrov"] = WorkerData("Petr", 43, ...);
        std::cout << "Ivanov's name = " << db["Ivanov"].name << "\n";
        std::cout << "Petrov's age = " << db["Petrov"].age << "\n";
    } */

    /**
     * Задание 3.2. Итератор.
     *
     * На практике воспользоваться таким классом будет довольно сложно, потому
     * что чтобы получить информацию о работниках, нужно откуда-то знать их
     * фамилии (ключи в массиве).
     *
     * Чтобы решить такую проблему, часто используют паттерн *итератор*.
     * Объект-контейнер (у нас - WorkerDb) умеет возвращать объект, который
     * перебирает его элементы. Для обычного массива в С таким объектом является
     * указатель, однако, сам по себе указатель не содержит информации, когда
     * элементы массива закончатся. Поэтому в пару к указателю, который
     * указывает на элементы (`begin`), добавляют указатель, который будет
     * обозначать, что элементы закончены (`end`):
     *
     * ```
     * int arr[] = {1, 2, 3, 4, 5};
     *
     * for (int *begin = arr, *end = arr + sizeof(arr) / sizeof(arr[0]);
     *      begin != end;
     *      ++begin)
     *  {
     *      std::cout << *begin << ' ';
     *  }
     *
     * ```
     *
     * В языке C++ наследуется эта идиома: объекты-контейнеры возвращают
     * объект-итератор методами `begin()` и `end()`. Для итератора определены
     * операторы `==`, `!=`, префиксный и постфиксный `++`, а также операторы
     * разыменования `*` и `->`. Также часто итераторы копируются (оператор
     * `=`).
     *
     * Реализуйте для вашего класса `WorkerDb` итератор, который при
     * разыменовании будет возвращать ссылку на `WorkerData`, а также иметь
     * метод `key()`, который будет возвращать ключ для этих данных
     * (фамилию). Итераторы допускается объявлять дружественными для
     * класса-контейнера.
     *
     * Проверьте ниже работу итератора.
     */

    /* {
        WorkerDb db;
        db["Ivanov"] = WorkerData("Ivan", 34, ...);
        db["Petrov"] = WorkerData("Petr", 43, ...);
        for (auto it = db.begin(); it != db.end(); ++it)
        {
            std::cout << it.key() << " -> " << it->name << '\n';
        }
    } */

    /**
     * Задание 3.3. Работа "прикладного программиста".
     *
     * Не меняя класс `WorkerDb`, напишите функцию `print_db(WorkerDb&)`,
     * которая будет печатать базу данных работников на консоль, и функцию
     * `double get_avg_age(WorkerDb&)`, которая будет подсчитывать средний
     * возраст сотрудников. Эти функции не должны быть дружественными классу
     * `WorkerDb`.
     */

    /**
     * Задание 4. Объединения, полиморфизм в "старом" стиле, очередь с
     * приоритетами.
     */

    /**
     * Задание 4.1. Класс "Уведомление".
     *
     * Создайте структуру `Notification`, в котором будет информация об
     * уведомлении, поступающем на телефон.
     *
     * Уведомление должно иметь метку времени и данные, которые зависят от типа
     * уведомления. Реализуйте следующие типы.
     *
     * 1. Системное уведомление: хранит сообщение и уровень серьезности (обычное
     *    или срочное).
     * 2. Мгновенное сообщение: выводится имя контакта, от которого сообщение, и
     *    текст сообщения.
     * 3. Уведомление от приложения: выводится название приложения, заголовок
     *    уведомления и текст уведомления.
     *
     * В этой структуре должно быть отдельное поле (enum), указыающее тип
     * данных, а специфичные данные находились бы в объединении (union).
     *
     * Добавьте функции для создание уведомлений каждого типа. Добавьте функции
     * или метод для красивого вывода данных уведомления. Добавьте функцию для
     * подсчета уведомлений заданного типа в массиве. Проверьте работу этих
     * функций.
     */

    /**
     * Задание 4.2. Отличие от наследования.
     *
     * Как эту же задачу можно было бы решить с помощью наследования классов? В чем
     * преимущества и недостатки каждого из методов?
     */

    /**
     * Задание 4.3. Очередь уведомлений.
     *
     * Реализуйте класс `NotificationQueue`, в котором были бы следующие методы:
     * 
     * - `push(notification)` - добавление уведомления в очередь;
     * - `size()` - количество уведомлений в очереди;
     * - `pop()` - возвращает следующее уведомление в порядке First In First
     *   Out (FIFO) и удаляет его из очереди;
     * - `begin()`, `end()` - возвращают итераторы для перебора всех элементов
     *   очереди, при операциях `push` или `pop` итераторы могут становиться
     *   невалидными.
     *
     * Проверьте работу этого класса.
     */

    /**
     * Задание 4.4. Определение приоритета.
     *
     * Реализуйте класс `NotificationPriorityQueue`, в котором были бы такие
     * же методы, как и в `NotificationQueue`, но метод `pop`, возвращал бы
     * не первое добавленное уведомление, а наиболее *актуальное* по следующим
     * правилам.
     *
     * 1. Срочное системное уведомление актуальнее любого другого уведомления.
     * 2. Уведомление тем актуальнее, чем раньше оно пришло (но срочное
     *    системное актуальнее более раннего уведомления другого типа).
     * 3. Среди уведомлений за один момент времени актуальность зависит от
     *    типа так: `мгновенное сообщение` > `обычное системное` >
     *    `уведомление от приложения`.
     * 4. Среди уведомлений одного типа за один момент времени актуальнее то,
     *    что было раньше добавлено в очередь.
     * 
     * Проверьте работу этого класса при помощи автоматических тестов.
     */

    /**
     * Задание 5. Неявно определенные операторы. Удаление операторов.
     *
     * Проверьте, определен ли оператор присваивания для класса `BaseFile` из
     * работы 2? Что он делает? Имеется ли смысл в таком операторе?
     *
     * Явно удалите оператор присваивания и конструктор копирования ключевым
     * словом `delete`, но определите их move-аналоги в этом классе.
     * Продемонстрируйте их работу.
     */

    {

    }

    /**
     * Задание 6. Оператор неявного приведения типа.
     *
     * Реализуйте класс `BoolArray`, представляющий динамический массив
     * логических значений (тип bool). В наивной реализации (`new bool[n]`) есть
     * проблема: каждая переменная типа bool занимает 1 байт, то есть 8 бит, в
     * то время как она могла бы занимать 1 бит.
     *
     * Реализуйте этот класс таким образом, чтобы каждое значение значений
     * действительно занимало 1 бит (точнее сказать, чтобы n значений занимали
     * не более ceil(n / 8), где ceil - целая часть числа с округлением вверх).
     *
     * Класс должен поддерживать следующее поведение:
     */

    /* {
        /// Создается массив из 10 значений false
        BoolArray ar1(10);

        /// Создается массив из 5 значений true
        BoolArray ar2(5, true);

        /// Создается независимая копия `ar2`
        BoolArray ar3(ar2);

        /// 4 и 6 элементу (нумерация с 0) устанавливаются заданное значение
        ar1[4] = ar1[6] = true;

        /// Над полученными значениями выполняем логические операции
        ar1[2] = (!ar1[6] && ar1[8] || (ar1[0] != true));

        /// Выведем массив на печать
        std::cout << "[";
        for (int i = 0; i < ar1.size(); ++i) {
            if (i > 0) std::cout << ", ";
            std::cout << ar1[i];
        }
        std::cout << "]\n";

        /// Выведем массив на печать по-другому
        std::cout << "[";
        for (int i = 0, printed = 0; i < ar1.size(); ++i) {
            if (ar1[i]) {
                if (printed++ > 0) std::cout << ", ";
                std::cout << i;
            }
        }
        std::cout << "]\n";


       /// Метод `resize` изменяет размер массива. Если новый размер больше, то
       /// новые значения дополняются заданным значением (по умолчанию false). Если
       /// новый размер меньше, то конец массива отбрасывается.

        ar1.resize(12, true);
        /// выведите массив на печать

        //...

        ar1.resize(4, true);
        /// выведите массив на печать снова

        //...

    } */

	return 0;
}
