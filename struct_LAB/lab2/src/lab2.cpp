/**
 * Лабораторная работа №2. Массивы объектов, простое наследование, виртуальные
 * функции, применение наследования.
 *
 * В этой работе и далее предполагается, что вы будете использовать классы,
 * написанные в прошлых работах, и дополнять их по необходимости. Эти классы
 * будут называться по имени без дополнительных указаний, что их надо взять из
 * прошлой работы.
 *
 * Предполагается, что новый классы будут созданы по аналогии с предыдущими
 * работами в отдельных файлах, которые будут включены в сборку.
 *
 * При работе с классами - в учебных целях - нельзя пользоваться контейнерами
 * стандартной библиотеки и нужно следовать принципам инкапсуляции.
 */

#include <iostream>
#include "MyString.hpp"
#include "BaseFile.hpp"
#include "Base32File2.hpp"
#include "RleFile2.hpp"
#include "cstring"

using namespace std;

int main() {
    /**
     * Задание 1. Массивы объектов класса.
     */

    /**
     * Задание 1.1. Массив объектов.
     *
     * Объявите и проинициализируйте массив ar из объектов типа MyString.
     * Выведите элементы массива на консоль.
     */

    {
        MyString ar[3] = { "Hello", "dsfdf","DSADSAD"};
        for (int i = 0; i<sizeof(ar)/sizeof(MyString); i++){
            ar[i].print();
            cout<<" ";
        }
        cout<<'\n';
        MyString arr[5] = { "Hello", "dsfdf", "DSADSAD" };
    }
    /**
     * Замените размер массива с 3 на 5, не меняя список инициализаторов.
     *
     * Чем были инициализированы последние 2 элемента? Какие значения могут
     * стоять в списке инициализаторов - в вашем случае и в общем случае?
     */

        /*  Для последних 2 значений вызывается конструктор по умолчанию, в моем случае это 
        MyString::MyString() : data(nullptr), len(0) {}, т.е. пустая строка.
            В общем случае если конструктор по умолчанию не определен, но при этом существуют другие конструкторы, то компилятор выдаст ошибку.
        В моем случае const char* str,  const MyString& other(конструктр копирования), в общем случае - значения, которые предусмотрел в конструкторах пользователь 
        */

    /**
     * Задание 1.2. Массив указателей на объекты.
     *
     * Объявите и проинициализируйте массив arPtr из трех указателей на объекты
     * типа MyString. Выведите элементы массива на консоль.
     */
    {
        MyString* s1= new MyString("Hello");
        MyString* s2= new MyString("DFSDF");
        MyString* s3= new MyString("ofpom");
        MyString* arPtr[3]={s1,s2,s3};
        for(int i = 0;i<sizeof(arPtr)/sizeof(MyString*);i++){
            arPtr[i]->print();
            cout<<" ";
        }
        cout<<'\n';
    }
    /**
     * Задание 2. Простое наследование. Аргументы конструктора, передаваемые в
     * базовый класс.
     */

    /**
     * Задание 2.1. Базовый класс.
     *
     * Создайте класс BaseFile, который будет реализовывать работу с файлами с
     * помощью стандартных средств C (cstdio).
     *
     * Класс должен иметь 3 конструктора: первый - конструктор по умолчанию,
     * второй должен принимать путь к файлу и параметры для открытия (как в
     * fopen), третий должен принимать готовый указатель FILE*.
     *
     * Считается, что этот класс *обладает* своим ресурсом - открытым файлом.
     * Что должно быть в дестукторе этого класса?
     *
     * Добавьте следующие методы:
     * - bool is_open() - возвращает true, если файл успешно открыт;
     * - bool can_read() - возвращает true, если из файла можно считать данные;
     * - bool can_write() - возвращает true, если в файл можно записать данные;
     * - size_t write_raw(const void *buf, size_t n_bytes) - записывает
     *   указанное количество байт в файл и возвращает количество байт, которое
     *   удалось записать; при этом, если метод вызывается повторно для того
     *   же объекта файла, запись должна продолжится в файл, а не начинаться
     *   заново; таким образом, последовательными вызовами метода `write_raw`
     *   можно записать сколь угодно большой файл;
     * - size_t read_raw(void *buf, size_t max_bytes) - читает доступные данные
     *   в буфер, но не более указанного количества и возвращает количество
     *   байт, которое удалось считать; при этом, если метод вызывается заново,
     *   для того же объекта файл, чтение должно продолжиться с того места,
     *   где чтение остановилось в прошлый раз; таким образом последовательными
     *   вызовами этого метода можно частями считать сколь угодно большой файл;
     * - long tell() - возвращает текущий сдвиг файла (см. функцию ftell);
     * - bool seek(long offset) - устанавливает сдвиг файла (см. функцию fseek)
     *   и возвращает true, если операция успешна.
     *
     * Добавьте также методы `read` и `write`, которые в этом классе будут
     * делать буквально то же, что `read_raw` и `write_raw`, они понадобятся нам
     * позже.
     *
     * Проверьте работу этого класса.
     */
    const char* filename = "data/test";
    const char* data = "KDNSFJkjdsnfk";
    {
        BaseFile f(filename, "w");
        if (!f.is_open()) {
            cout << "Не удалось открыть файл\n";
            return 1;
        }
        size_t written = f.write(data, strlen(data));
        cout << "Записано байт: " << written << "\n";
    }
    {
        char buffer[50] = {0};
        BaseFile f(filename, "rb"); // открыть для чтения
        if (!f.is_open()) {
            cout << "Не удалось открыть файл\n";
            return 1;
        }

        size_t k = f.read(buffer, sizeof(buffer));
        cout << "Прочитано байт: " << k << "\n";
        cout << "Содержимое: " << buffer << "\n";
    }
    /**
     * Задание 2.2. Производные классы.
     *
     * Производный класс *наследуется* от базового класса и каким-то образом
     * расширяет его функциональность, при это все еще умея все, что умеет
     * базовый класс.
     *
     * Реализуйте следующие производные классы от класса BaseFile. Производные
     * классы нужно унаследовать так, чтобы пользователю были все еще доступны
     * методы базового класса. Каким образом нужно унаследовать класс для этого?
     * Как еще можно унаследовать класс?
     * 
     * Нужно в качестве ключа доступа указать public, это позволит пользователю пользоваться всеми методами,
     * что и до этого. Также можно указать protected: тогда методами класса смогут пользоваться производные классы
     * и private: тогда методами можно будет пользоваться только внутри класса.
     * 
     *
     * Производные классы могут располагаться в том же файле, где и базовый
     * класс.
     *
     * В производных классах добавьте необходимые конструкторы, которые будут
     * вызывать конструктор базового класса.
     *
     * Проверьте работу производных классов.
     */

    /**
     * Задание 2.2.1. Base32 кодировщик/декодировщик.
     *
     * Создайте производный класс Base32File, который будет проводить при
     * записи кодировку-декодировку данных, по алгоритму, который вы
     * реализовали в лабораторной работе №4 прошлого семестра.
     *
     * Переопределите методы `read` и `write`, которые будут проводить чтение из
     * файла с декодировкой и запись в файл с кодировкой соответственно.
     *
     * Обратите внимание, что методы `read` и `write` должны иметь ту же логику
     * при последовательном вызове, что и методы `read_raw` и `write_raw` в
     * классе BaseFile, то есть *продолжать* чтение и запись дальше без потери
     * данных.
     *
     * Добавьте возможность пользователю передать в конструктор таблицу
     * кодировки, по умолчанию используется таблица "A..Z1..6".
     */
    {
        const char* msg = "Hello!";
        char buf[100] = {0};
        Base32File("test2", "w").write(msg, strlen(msg));

        BaseFile f_raw("data/test2", "r");
        f_raw.read_raw(buf, sizeof(buf));
        cout << "В файле (Base32): " << buf << '\n';

        memset(buf, 0, sizeof(buf)); // очистка буфера
        Base32File("data/test2", "r").read(buf, sizeof(buf));
        cout << "Декодировано:" << buf << '\n';
    }
    /**
     * Задание 2.2.2. RLE-сжатие.
     *
     * Создайте производный класс RleFile, который будет проводить побайтовое
     * сжатие при помощи алгоримта RLE (для простоты можно реализовать
     * неэффективный алгоритм, где последовательности без повторений отдельно
     * не кодируются).
     *
     * Переопределите методы `read` и `write`, которые будут проводить чтение из
     * файла с извлечением сжатой информации и запись в файл со сжатием
     * соответственно.
     *
     * Обратите внимание, что методы `read` и `write` должны иметь ту же логику
     * при последовательном вызове, что и методы `read_raw` и `write_raw` в
     * классе BaseFile, то есть *продолжать* чтение и запись дальше без потери
     * данных.
     *
     * Проверьте сжатие/извлечение на примере какого-нибудь ASCII-арта,
     * например, котенка из лабораторной №3 прошлого семестра. Посмотрите,
     * получилось ли добиться уменьшения размера хранимых данных.
     */
    {
        const char* cat = 
        "      /_/\\  (\n"
        "     ( ^.^ ) _)\n"
        "      \"/  (\n"
        "     ( | | )\n"
        "    (__d b__)\n"
        "..............................";
        char buf[512] = {0};

        RleFile("data/cat.rle", "wb").write(cat, strlen(cat));

        BaseFile f("data/cat.rle", "rb");
        f.seek(0); 
        size_t compressed_size = f.read_raw(buf, 512);//читаем всё в буфер и смотрим, сколько байт реально в файле

        cout << "Исходный размер: " << strlen(cat) << " байт" << '\n';
        cout << "Сжатый размер:   " << compressed_size << " байт" << '\n';

        memset(buf, 0, 512);
        RleFile("data/cat.rle", "rb").read(buf, 512);
        cout << "\n котенок:\n" << buf << '\n';

        return 0;
    }
    /**
     * Задание 2.3. Конструкторы и деструкторы базового и производного классов.
     *
     * Установите отладочную печать в конструкторах и деструкторах каждого
     * класса из этого задания. Создайте локальные объекты производных классов,
     * отметьте, в каком порядке вызываются конструкторы и деструкторы при
     * инициализации и деинициализации этих классов.
     */
    {   { 
            Base32File test32("data/test32.txt", "w");//здесь сначала слздаться конструктор базового класса, потом производного
        }//здесь область видимости заканчивается и вызывается деструктор производного класса, а потом базового.
        //В конструкторе производного класса я прописал, что нужно вызвать конструктор базового, но в деструкторе такого нет.
        //Деструктор производного кдасса неявно вызывает деструктор базового  
        {
            RleFile testRle("data/test.rle", "w");
        }
        // то же самое
    }
    /**
     * Задание 2.4. Ранее связывание.
     *
     * На основе данной заготовки напишите код, который запишет в файл строковое
     * представление целого числа. Вы должны использовать один и тот же код для
     * всех файлов, меняя только имя объекта (bf / b32f / rf), в который идет
     * запись.
     */

    {
        BaseFile bf("data/int_base.txt", "w");
        Base32File b32f("data/int_b32.txt", "w");
        RleFile rf("data/int_rle.txt", "w");

        {
            int n = 123456;
            if (n == 0)
                bf.write("0", 1);
            if (n < 0){
                bf.write("-", 1);
                n = -n;
            }
            char buf[20]; // Буфер для числа
            int i = 0;
            while (n > 0) {
                buf[i++] = (n % 10) + '0'; // т.к. int более точный тип '0' приводится к типу int = 48, далее число приводится к char 
                n /= 10;
            }
            while (i > 0) {
                bf.write(&buf[--i], 1);// меняем порядок цифр 
            }
        }
        {
            int n = 123456;
            if (n == 0)
                b32f.write("0", 1);
            if (n < 0){
                b32f.write("-", 1);
                n = -n;
            }
            char buf[20]; // Буфер для числа
            int i = 0;
            while (n > 0) {
                buf[i++] = (n % 10) + '0'; // т.к. int более точный тип '0' приводится к типу int = 48, далее число приводится к char 
                n /= 10;
            }
            while (i > 0) {
                b32f.write(&buf[--i], 1);// меняем порядок цифр 
            }
        }

        {
            int n = 123456;
            if (n == 0)
                rf.write("0", 1);
            if (n < 0){
                rf.write("-", 1);
                n = -n;
            }
            char buf[20]; // Буфер для числа
            int i = 0;
            while (n > 0) {
                buf[i++] = (n % 10) + '0'; // т.к. int более точный тип '0' приводится к типу int = 48, далее число приводится к char 
                n /= 10;
            }
            while (i > 0) {
                rf.write(&buf[--i], 1);// меняем порядок цифр 
            }
        }
    } 

    /**
     * Задание 2.5. Передача объекта по ссылке / указателю.
     *
     * Прошлое задание выглядит странновато - зачем повторять код три раза?
     * Хорошо бы сделать функцию, которая примет объект файла и число, и
     * выполнит эти действия.
     *
     * Реализуйте функцию `write_int(BaseFile &file, int n)`, которая будет
     * принимать ссылку на файл и число, которое нужно будет напечатать.
     *
     * Принцип наследования предписывает, что везде, где можно использовать
     * базовый класс, можно использовать производный класс. Проверьте, можно
     * ли вызвать функцию, передав в нее объект класса Base32File и RleFile.
     *
     * Имеет ли вызов этой функции для производного класса тот же результат,
     * что и код, который вы написали выше? Почему?
     */
    {
        BaseFile bf("data/int_base.txt", "w");
        Base32File b32f("data/int_b32.txt", "w");
        RleFile rf("data/int_rle.txt", "w");

        int number=213232;
        write_int(bf, number);    
        write_int(b32f, number); 
        write_int(rf, number);    
    }
    /*
        1)Да, функцию можно вызывать передав в качестве аргументов объекты производных классов.
        2)Изначально я сделал функции виртаульными, и у меня результат не менялся, но когда я убрал ключевое слово virtual, во втором случае результат изменился, в каждом 
        файле находился одинаковый результат, потому что решение о том, какую функцию вызвать принимается компилятором сразу, по типу указателя, а у меня указатель базового типа,
        поэтому для всех производных классов вызвался один и тот же родительский метод. 
    */
    /**
     * Задание 2.6. Виртуальные функции, позднее связывание.
     *
     * Объявите функции read и write в базовом классе *виртуальными*. Что это
     * означает? Как изменился размер объектов классов BaseFile, Base32File и
     * RleFile? Почему?
     *
     * В предыдущем задании частично ответил. Это означает, что тебя происходит не ранее связывание, на этапе компиляции, а позднее, с помощью таблицы vtbl и указателя vptr.
     * Размер файлов увлеичился, как раз потому, что добавился указатель vptr(указатели занимают 8 байт)
     * 
     * Как изменилось поведение при вызове функции `write_int` для производных
     * классов? Почему?
     * 
     * Теперь при вызове функций выполняется реализация производного класса, а не родителя.
     * При встречи метода, комплиятор не знает адрес функции, он ищет по указателю в таблице этот адрес 
     */

    /**
     * Задание 2.7. Виртуальный деструктор.
     *
     * В следующем блоке кода добавьте удаление динамической памяти.
     *
     * Какой деструктор при этом вызывается? Почему? К каким проблемам это может
     * привести?
     *де
     * Исправьте эту ситуацию.
     */

    {
        BaseFile *files[] = { 
            new BaseFile(), 
            new RleFile(), 
            new Base32File(), 
        };

        for (int i = 0; i < 3; ++i) {
            files[i]->write("Hello!", 6);
        }
        for (int i = 0; i < 3; ++i) {
            delete files[i];
        }
    } 
    /*Если не указать virtual, то ситуация будет анологичная, тип указателя basefile, поэтому вызовется только деструктор базового класса, что приведет к утечке памяти,
    а если указать virtual, то сначала произойдет вызов деструктора производного класса, а далее, как я ранее писал, он неявно вывзвает деструктор базового класса
    */

    /**
     * Задание 2.8. Массив объектов производных классов.
     *
     * Раскомментируйте следующий блок и объясните, почему:
     * а) не возникает ошибок при компиляции;
     * б) возникают ошибки при выполнении.
     *
     * Этот пример показывает очень плохую практику, которая приводит к ошибкам;
     * для создания массива объектов производного класса и используйте массив
     * указателей на базовый класс, как это было сделано выше. Реализуйте ту же
     * логику, используя массив указателей на объекты базового класса.
     */

    /* {
        BaseFile *base_files = new BaseFile[2] { BaseFile(...), BaseFile(...) };
        BaseFile *b32_files = new Base32File[2] { Base32File(...), Base32File(...) };
        for (int i = 0; i < 2; ++i) {
            base_files[i].write("Hello!", 6);
            b32_files[i].write("Hello!", 6);
        }
        delete [] base_files;
        delete [] b32_files;
    }
    компилятор считает такое приведение корректным и думает, что работа производятся с объектами базового класса т.к. base32file является производным классом.
    Ошибки из-за того, что размер каждого объекта разный, и когда происходит поиск индекса в массиве, то в памяти учитывается размер одного объекта. Поэтому лучше хранить указатели
    */
    {
        BaseFile **files = new BaseFile*[2]; 
        
        files[0] = new Base32File("data/file1.b32", "w");
        files[1] = new Base32File("data/file2.b32", "w");

        for (int i = 0; i < 2; i++) {
            files[i]->write("Hello!", 6);// files[i] - указатель. Смещение i * sizeof(pointer) одинаково для любых объектов.
        }

        for (int i = 0; i < 2; i++) {
            delete files[i]; 
        }
        delete[] files;
    }

    /**
     * Задание 3. Чисто виртуальные функции. Интерфейсы. Композиция классов.
     *
     * Наследование позволяет довольно просто переиспользовать данные и логику
     * других классов, однако зачастую этот механизм недостаточно гибкий для
     * полноценного переиспользования.
     *
     * Например, сможем ли мы в получившейся иерархии классов реализовать
     * одновременно и кодирование в base32, и сжатие при записи данных в файл?
     * Или сможем ли мы вместо записи в файл на диске делать запись в строковый
     * буфер в памяти?
     *
     * При дальнейшем рассмотрении окажется, что при помощи наследования мы
     * крепко *связали* логику преобразования данных с записью в конкретный
     * файл. Далее мы рассмотрим один из способов разделения такой логики.
     */

    /**
     * Задание 3.1. Абстрактный базовый класс, чисто виртуальные функции.
     *
     * Первая проблема в нашей реализации - все наследники BaseFile будут всегда
     * обязаны непосредственно писать в файл на диске. Чтобы избавиться от этой
     * необходимости, стоит сделать базовый класс *абстрактным* в том смысле,
     * что у него не будет полей связанных с конкретным способом писать в файл.
     *
     * Создайте класс `IFile`, в котором не будет полей, но будут методы
     * `can_read`, `can_write`, `read` и `write` с такими же сигнатурами, как и
     * классе `BaseFile`. Что именно будут делать эти методы? Класс `IFile` не
     * может знать, поскольку логику этих методов будут определять наследники.
     * В этом классе эти методы не имеют реализации, и они должны быть объявлены
     * *чисто виртуальными*.
     *
     * Какие ограничения накладывает на класс наличие чисто виртуального метода?
     * 
     * Наличие хотя бы одного виртуального меода делает класс абстрактным.
     * 1. объекты абстрактного класса создавать нельзя
     * 2. абстрактный класс нельзя использовать при явном приведении типов, для
     * описания типа параметра и типа возвращаемого функцией значения;
     * 3. допускается объявлять указатели и ссылки на абстрактный класс, если при
     *  инициализации не требуется создавать временный объект;
     * 
     * 
     * Получается, что в классе `IFile` есть только чисто виртуальные методы, и
     * единственная цель такого класса - определять, что должны уметь делать его
     * наследники. Совокупность действий, которые можно сделать с объектом,
     * называется его *интерфейсом*, и такие классы тоже часто называются
     * интерфейсами, отсюда берется приставка "I" в имени класса.
     *
     * Унаследуйте класс `BaseFile` от класса `IFile` и измените функцию
     * `write_int`, чтобы она работала с произвольным наследником `IFile`.
     *
     * Убедитесь, что в программе выше ничего не сломалось. ле
     */

    /**
     * Задание 3.2. Композиция вместо наследования.
     *
     * Реализуйте классы `Base32File2` и `RleFile2`, которые будут унаследованы
     * от класса `IFile` и в конструкторе будут получать другой объект `IFile`,
     * чьи функции они будут использовать вместо функций базового класса.
     *
     * Объекты получают объект `IFile` в виде указателя на динамически
     * выделенную память, и они ответственны за ее очищение.
     *
     * Использование объектом другого объекта в качестве поля называется
     * *композицией*.
     *
     * Проверьте, что используемые ниже объекты работают так же, как объекты
     * классов `Base32File` и `RleFile`.
     */

    {
        Base32File2 b32f(new BaseFile("data/test_b32.txt", "wb"));
        RleFile2 rf(new Base32File("data/test_rle.txt", "wb"));
        write_int(b32f, 123456);
        write_int(rf, 123456);
    } 

    /**
     * Задание 3.3. Больше композиции!
     *
     * Не реализовывая больше никаких классов, соорудите объект-наследник IFile,
     * который будет при вызове метода `write` два раза кодировать в base32,
     * после чего применять сжатие RLE и только после этого писать в файл.
     */

    {
        const char* table = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456";
        RleFile2 combo(
            new Base32File2(
                new Base32File2(new BaseFile("data/combo.txt", "wb"), table),table)
        );// строим цепочку: Base32 → Base32 → RLE → BaseFile
        write_int(combo, 987654);
    }

    /**
     * Задание 4. Тестирование классов.
     *
     * Убедитесь, что для всех ваших классов проходится следующий тест.
     *
     * 1. Сгенерируйте большой массив случайных данных (> 40Кб).
     * 2. Запишите эти данные во временный файл с помощью класса, который вы
     *    тестируете (сделайте отдельный тест для каждого класса и для пары
     *    вариантов композиции), при этом запись делайте буферами малого размера
     *    (256 байт).
     * 3. Прочитайте этот файл объектом этого же класса, последовательно вызывая
     *    метод `read` с буфером малого размера (256 байт). Сравните побайтово
     *    содержимое, прочитанное таким образом, с массивом, полученным в п. 1.
     *
     * Проверку для каждого типа файла оформите в виде отдельного
     * автоматического теста, настройте запуск для всех тестов в виде отдельной
     * цели (например, `make test`).
     */


    return 0;
}
